---
layout: post
title: HTTP와 네트워크의 기본 - 5
subtitle: HTTP 프로토콜과 네트워크 기본 지식을 탐구해보자
tags: [Network, Web, Server]
author: Im Yongsik
comments: True
use_math: True
---

## 0. 서론

이번 포스트에서는 HTTP Protocol 기반 통신을 돕는 웹 서버 구성 기술들을 살펴보자.

## 1. TL;DR

* 가상 호스트(Virtual Host)기능을 통해 1대의 물리적 서버에서 여러 서버를 운영할 수 있다.
* 프록시(Proxy), 게이트웨이(Gateway), 터널(Tunnel), 캐시(Cache)는 클라이언트-서버 간 통신을 중계하는 구성 요소이다
* 프록시(Proxy)는 클라이언트/서버 양 역할을 모두 수행하며 메시지를 중계한다
* 게이트웨이(Gateway)는 클라이언트/서버 양 역할을 수행하며 HTTP 이외의 서버에 메시지를 중계한다
* 터널(Tunnel)은 클라이언트-서버 간 안전한 통신 경로를 확립한다.
* 캐시(Cache)는 리소스를 보관하는 역할을 한다

## 2. 가상 호스트(Virtual Host)

HTTP/1.1 이후 가상 호스트 라는 기술이 추가되었다. 이는 한 대의 물리적 서버에서 여러 개의 가상 서버를 운영할 수 있게 해 주는 기술이다. 즉, 한 대의 서버 기기가 A, B, C, D라는 사이트를 모두 운영할 수 있게 해 주는 기술이다.

<br>

다만 이 때 A.com, B.com, C.com, D.com 이라는 각 사이트의 주소는 **도메인 주소**이다. 따라서 DNS에 의해 도메인 주소가 IP주소로 바뀌게 되면 네 주소는 모두 같은 물리 서버의 IP주소로 변환된다. 이 경우 서버의 입장에서는 클라이언트가 A, B, C, D중 어느 사이트에 대한 메시지를 요청했는지 알 수 없게 된다.

<br>

이를 위해 HTTP/1.1 이상의 메시지에서는 헤더에 도메인 주소와 호스트명을 완전하게 포함한 URI, 혹은 호스트 필드에 호스트명을 지정한 헤더를 삽입해 요청해야 한다.

<p align="center">
    <img src="{{site.baseurl}}/assets/img/posts/2022-09-15/Http-Network-Basic-04/img01.jpg" />
</p>

## 3. 프록시(Proxy) 서버

프록시 서버는 서버와 클라이언트 사이에서 메시지를 중계해 주는 중계 서버 중 하나이다. 특히 그 중 프록시 서버는 클라이언트와 서버의 역할을 모두 수행한다. 즉, 클라이언트로부터 받은 리퀘스트를 그대로 실제 서버(Origin Server)에 전달해 주고, 서버로부터 받은 리스폰스를 실제 클라이언트에 전달해 주는 역할을 수행한다. 이 때 클라이언트의 역할을 대신하는 것을 **포워드 프록시(Forward Proxy)**라 하고, 서버의 역할을 대신하는 것을 **리버스 프록시(Reverse Proxy)**라 한다.

<p align="center">
    <img src="{{site.baseurl}}/assets/img/posts/2022-09-15/Http-Network-Basic-04/img02.jpg" />
</p>

이렇게만 보면 프록시 서버와 라우터가 무슨 차이인가 하는 의문이 들 수 있는데, 대표적으로 다음과 같은 차이가 존재한다.

|      기능/구성      |    라우터    |   프록시 서버   |
| :-----------------: | :----------: | :-------------: |
|      전달 객체      | 패킷(Packet) | 메시지(Message) |
| 전달 객체 가공 여부 |      X       |        X        |
|     TCP/IP 계층     |  2(Network)  | 4(Application)  |
|      부가 기능      |      X       |        O        |

둘의 차이를 보면 가장 먼저 TCP/IP 계층의 차이가 있다. 프록시 서버의 경우 TCP/IP 4계층(OSI 7계층)에서 역할을 수행하며 라우터의 경우 TCP/IP 2계층(OSI 3계층)에서 그 역할을 수행한다.

<br>

무엇보다 중요한 점이 바로 부가 기능의 유무인데, 라우터의 경우 단순히 IP주소를 기준으로 패킷 중계의 역할을 하는 것이 전부이지만 프록시 서버의 경우 어플리케이션 레이어까지 메시지를 끌어올리게 되므로 어플리케이션 단에서 가능한 처리들을 모두 할 수 있다.

<br>

대표적인 예가 리소스 캐싱, 익명성 부여, 트래픽 통제 등이다.

<br>

모두가 한 번쯤 겪어봤을 예시로, 회사나 공공기관 등에서 접속이 제한된 특정 사이트에 접속하고자 하면 프록시 응답이 없어 접속할 수 없다는 메시지가 나타나며 접속이 차단되는 것을 본 적이 있을 것이다. 이 경우는 사실 해당 기관의 모든 네트워크가 외부로 연결되기 전 프록시 서버를 하나 거치도록 구성한 후 해당 프록시 서버에서 특정 사이트들을 제한하는 트래픽 통제를 설정함으로써 이러한 기능이 작동하게 된 것이다.

<p align="center">
    <img src="{{site.baseurl}}/assets/img/posts/2022-09-15/Http-Network-Basic-04/img03.jpg" />
</p>

또, 클라이언트와 서버가 통신하는 과정에서 여러 대의 프록시 서버를 거쳐갈 수 있는데, 이처럼 여러 프록시 서버가 중계를 연속해 주는 것을 **체이닝(Chaining)**이라 하며 이러한 형태를 **프록시 체인(Proxy Chain)**이라 한다. 

<p align="center">
    <img src="{{site.baseurl}}/assets/img/posts/2022-09-15/Http-Network-Basic-04/img04.jpg" />
</p>

## 4. 게이트웨이(Gateway)

**게이트웨이(Gateway)**의 경우 동작 방식은 프록시 서버와 매우 유사한데, 그 기능에는 차이가 있다.

우선 클라이언트/서버 양 역할을 모두 수행한다는 점에서는 프록시 서버와 유사하지만 게이트웨이는 메시지를 전달해 줄 실제 서버가 HTTP서버가 아닌 다른 프로토콜 서버이다.

<br>

이는 클라이언트와 게이트웨이 사이의 통신을 암호화하는 것처럼 안전성을 담보하는 효과를 가진다.

<br>

게이트웨이는 주로 신용카드 결제 페이지나 직접 DB에 접속하는 페이지 등에 접근하기 위해 사용된다.

<p align="center">
    <img src="{{site.baseurl}}/assets/img/posts/2022-09-15/Http-Network-Basic-04/img05.jpg" />
</p>

## 5. 터널(Tunnel)

터널은 앞서 살펴본 두 서버들과 달리 단순한 기능을 수행한다. 바로 통신 연결을 확립하고 안전한 통신이 가능하도록 돕는 것이다.

<br>

따라서 터널은 별도의 부가 기능은 수행하지 않으며, 전달받은 메시지를 바로 다음 서버에 전달한다. 이러한 점 때문에 클라이언트 입장에서도 터널의 존재를 크게 신경쓸 필요가 없게 된다.

<br>

터널은 주로 SSL과 같은 암호화 통신을 필요로 할 때 사용된다. 

<p align="center">
    <img src="{{site.baseurl}}/assets/img/posts/2022-09-15/Http-Network-Basic-04/img06.jpg" />
</p>

## 6. 캐시(Cache) 서버

CPU와 메모리 사이에 캐시 메모리가 존재해 연속적인 데이터나 메모리에서 인출한 데이터를 임시 저장하는 것처럼 웹 서버에도 캐싱 기능을 가진 서버가 존재하는데, 바로 **캐시 서버(Cache Server)**이다.

<br>

캐시 서버는 클라이언트와 서버의 브라우저 혹은 로컬 저장 장치에 저장된 리소스, 즉 캐시를 다른 서버에 전달함과 동시에 그 사본을 자신의 로컬 저장 장치에 저장하는데, 이는 이후 클라이언트가 같은 데이터를 또 요청할 때 최종 서버까지 메시지를 중계하지 않고 캐시 서버 자신이 직접 그 리소스를 전달해 줌으로써 서버 부하를 줄이고 요청에 대한 처리 속도를 높일 수 있게 하는 요인이 된다.

<br>

그러나 CPU캐시와 동일하게 캐시 서버의 저장 장치도 용량의 한계가 존재하기 때문에, 캐싱 데이터가 서버 상에서 변경되었거나 변경이 의심되는 경우, 또는 다른 데이터들로 인해 기존 데이터가 덮어씌워진 경우에는 다시 최종 서버(Origin Server)로부터 리소스를 받아와야 한다.

<p align="center">
    <img src="{{site.baseurl}}/assets/img/posts/2022-09-15/Http-Network-Basic-04/img07.jpg" />
</p>
